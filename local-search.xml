<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hexo搭建博客</title>
    <link href="/2022/10/06/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2022/10/06/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="Hexo搭建博客"><a href="#Hexo搭建博客" class="headerlink" title="Hexo搭建博客"></a>Hexo搭建博客</h2><h2 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h2><blockquote><p><a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li><p>安装基础环境</p><blockquote><p>Node.js和git</p></blockquote></li><li><p>安装Hexo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli<br></code></pre></td></tr></table></figure></li><li><p>建站</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init blog<br></code></pre></td></tr></table></figure><p>目录结构如下</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1h6ue0d3bbnj30vg0c0jti.jpg" alt="image-20221005141812611"></p></li><li><p>初始化博客内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 进入目录</span><br><span class="hljs-built_in">cd</span> blog<br><span class="hljs-comment"># </span><br>npm install<br></code></pre></td></tr></table></figure></li><li><p>开启服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 生成html等静态资源文件</span><br>hexo generate <span class="hljs-comment"># 也可以使用缩写版本：hexo g</span><br><span class="hljs-comment"># 启动服务</span><br>hexo server<span class="hljs-comment"># 也可以使用缩写版本：hexo s</span><br><span class="hljs-comment"># 后台启动</span><br><span class="hljs-built_in">nohup</span> hexo server &amp;<br></code></pre></td></tr></table></figure><blockquote><p>PS. 生成资源文件时，不会覆盖重名的文件，比如图片banner</p></blockquote></li><li><p>访问<a href="http://localhost:4000/">http://localhost:4000/</a></p></li></ol><h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><h4 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h4><blockquote><ol><li><p>克隆NexT主题到themes文件夹</p><p>git clone <a href="https://github.com/iissnan/hexo-theme-next">https://github.com/iissnan/hexo-theme-next</a></p></li><li><p>下载Fluid主题解压到themes文件夹</p><blockquote><p>主题官网文档：<a href="https://hexo.fluid-dev.com/docs/">https://hexo.fluid-dev.com/docs/</a></p></blockquote><p><a href="https://github.com/fluid-dev/hexo-theme-fluid">https://github.com/fluid-dev/hexo-theme-fluid</a></p><p>PS. 使用fluid主题时，下载下来的文件夹名字是这样的<code>hexo-theme-fluid-1.9.3</code>，需要将其修改为<code>fluid</code>；</p></li></ol></blockquote><h4 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h4><blockquote><p>修改<code>_config.yml</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># theme: next  # 指定主题</span><br>theme: fluid  <span class="hljs-comment"># 指定主题</span><br>language: zh-CN  <span class="hljs-comment"># 指定语言，会影响主题显示的语言，按需修改</span><br></code></pre></td></tr></table></figure><h3 id="创建「关于页」"><a href="#创建「关于页」" class="headerlink" title="创建「关于页」"></a>创建「关于页」</h3><blockquote><p>首次使用主题的「关于页」需要手动创建：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new page about<br></code></pre></td></tr></table></figure><p>创建成功后，编辑博客目录下 <code>/source/about/index.md</code>，添加 <code>layout</code> 属性。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">about</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2020-02-23 19:20:33</span><br><span class="hljs-attr">layout:</span> <span class="hljs-string">about</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-string">这里写关于页的正文，支持</span> <span class="hljs-string">Markdown,</span> <span class="hljs-string">HTML</span><br></code></pre></td></tr></table></figure><h3 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new post 测试文章<br></code></pre></td></tr></table></figure><h3 id="站点设置"><a href="#站点设置" class="headerlink" title="站点设置"></a>站点设置</h3><p>修改<code>_config.yml</code>即可</p><h3 id="阅读量统计"><a href="#阅读量统计" class="headerlink" title="阅读量统计"></a>阅读量统计</h3><blockquote><p>账号注册：<a href="https://console.leancloud.cn/register">https://console.leancloud.cn/register</a></p><p>需身份验证和邮箱验证</p></blockquote><p><strong>创建应用</strong></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1h6ul097k1hj310c0u0jtn.jpg" alt="image-20221005182005192"></p><p><strong>获取应用appid</strong></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1h6ul5uerwmj31fj0u0tcs.jpg" alt="image-20221005182543636"></p><p>打开主题目录 <code>themes\fluid</code>下的 <code>_config.yml</code> 文件，修改如下配置</p><ol><li>开启统计</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1h6ulacrda9j316u0jejup.jpg" alt="image-20221005183006359"></p><ol start="2"><li>配置 <code>leancloud</code>的 <code>app_id</code> 、 <code>app_key</code>和<code>REST API 服务器地址</code></li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1h6ulbksgsfj31qi0e6tb8.jpg" alt="image-20221005183114159"></p><ol start="3"><li>打开计数功能，统计来源改为 <code>leancloud</code></li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1h6ullnp2s0j316009umxn.jpg" alt="image-20221005184055476"></p><ol start="4"><li><h5 id="页面底部展示网站的-PV、UV-统计数"><a href="#页面底部展示网站的-PV、UV-统计数" class="headerlink" title="页面底部展示网站的 PV、UV 统计数"></a>页面底部展示网站的 PV、UV 统计数</h5></li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1h6uluh1shzj326y0mmjvd.jpg" alt="image-20221005184926645"></p><h3 id="开启评论功能"><a href="#开启评论功能" class="headerlink" title="开启评论功能"></a>开启评论功能</h3><p>打开主题目录 <code>themes\fluid</code>下的 <code>_config.yml</code> 文件，修改如下配置</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1h6um4h4mvnj31k208sgmi.jpg" alt="image-20221005185903196"></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1h6ulyco78nj31e80jognp.jpg" alt="image-20221005185309930"></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>站点设置：根目录<code>_config.yml</code></p><p>主题设置：根目录<code>_config.fluid.yml</code></p><h2 id="在Github上托管"><a href="#在Github上托管" class="headerlink" title="在Github上托管"></a>在Github上托管</h2><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1h6umofe7r5j31030qcq5y.jpg" alt="image-20221005191814021"></p><h3 id="创建token"><a href="#创建token" class="headerlink" title="创建token"></a>创建token</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1h6um9ofdiwj316d0hwgnj.jpg" alt="image-20221005190403282"></p><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1h6umb5r6m0j318e07ewfc.jpg" alt="image-20221005190528703"></p><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><blockquote><p>部署后的渲染有点慢，不要着急，请耐心等待~</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g -d<br></code></pre></td></tr></table></figure><h3 id="创建Readme文件"><a href="#创建Readme文件" class="headerlink" title="创建Readme文件"></a>创建Readme文件</h3><p>&#x3D;&#x3D;<strong>发布后记得添加Readme.md文件，否则网站无法访问</strong>&#x3D;&#x3D;</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1h6umqfxdz7j31fq0oxdkf.jpg" alt="image-20221005192010048"></p><h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p><a href="https://unclebryan719.github.io/">https://unclebryan719.github.io/</a></p><h3 id="域名映射"><a href="#域名映射" class="headerlink" title="域名映射"></a>域名映射</h3><blockquote><p>直接在设置页面配置域名即可，我没有配置域名解析也成功了</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1h6vn6q61xyj317x0u00xj.jpg" alt="image-20221006162117603"></p><blockquote><p>配置后会生成一个CNAME的文件，记得把它copy到public文件夹，否则，每次自定义域名都会被清除</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1h6voj5d0lvj316l0u00xp.jpg" alt="image-20221006170751802"></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1h6vojn25xzj318m0u0aek.jpg" alt="image-20221006170823489"></p>]]></content>
    
    
    <categories>
      
      <category>tech</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>blog</tag>
      
      <tag>tech</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElasticSearch</title>
    <link href="/2022/09/29/ElasticSearch/ElasticSearch/"/>
    <url>/2022/09/29/ElasticSearch/ElasticSearch/</url>
    
    <content type="html"><![CDATA[<h1 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h1><h4 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h4><blockquote><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/index.html">https://www.elastic.co/guide/en/elasticsearch/reference/index.html</a></p></blockquote><h4 id="安装ES"><a href="#安装ES" class="headerlink" title="安装ES"></a>安装ES</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker network create elastic<br>docker pull docker.elastic.co/elasticsearch/elasticsearch:7.17.6<br>docker run --name es01-test --net elastic -p 127.0.0.1:9200:9200 -p 127.0.0.1:9300:9300 -e <span class="hljs-string">&quot;discovery.type=single-node&quot;</span> docker.elastic.co/elasticsearch/elasticsearch:7.17.6<br></code></pre></td></tr></table></figure><h4 id="安装Kibana"><a href="#安装Kibana" class="headerlink" title="安装Kibana"></a>安装Kibana</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull docker.elastic.co/kibana/kibana:7.17.6<br>docker run --name kib01-test --net elastic -p 127.0.0.1:5601:5601 -e <span class="hljs-string">&quot;ELASTICSEARCH_HOSTS=http://es01-test:9200&quot;</span> docker.elastic.co/kibana/kibana:7.17.6<br></code></pre></td></tr></table></figure><h4 id="访问Kibana"><a href="#访问Kibana" class="headerlink" title="访问Kibana"></a>访问Kibana</h4><blockquote><p><a href="http://localhost:5601/">http://localhost:5601</a></p></blockquote><h4 id="Search-Api"><a href="#Search-Api" class="headerlink" title="Search Api"></a>Search Api</h4><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.17/search-search.html">https://www.elastic.co/guide/en/elasticsearch/reference/7.17/search-search.html</a></p><h4 id="Query-DSL"><a href="#Query-DSL" class="headerlink" title="Query DSL"></a>Query DSL</h4><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.17/query-dsl.html">https://www.elastic.co/guide/en/elasticsearch/reference/7.17/query-dsl.html</a></p>]]></content>
    
    
    <categories>
      
      <category>es</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tech</tag>
      
      <tag>es</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RocketMq</title>
    <link href="/2022/07/12/Middleware/MessageQueue/RocketMq/"/>
    <url>/2022/07/12/Middleware/MessageQueue/RocketMq/</url>
    
    <content type="html"><![CDATA[<h2 id="RocketMq"><a href="#RocketMq" class="headerlink" title="RocketMq"></a>RocketMq</h2><h3 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">unzip rocketmq-all-4.9.4-source-release.zip</span><br><span class="hljs-meta prompt_"> &gt; </span><span class="language-bash"><span class="hljs-built_in">cd</span> rocketmq-all-4.9.4-source-release/</span><br><span class="hljs-meta prompt_"> # </span><span class="language-bash">改完配置需要重新编译</span> <br><span class="hljs-meta prompt_"> &gt; </span><span class="language-bash">mvn -Prelease-all -DskipTests clean install -U</span><br><span class="hljs-meta prompt_"> &gt; </span><span class="language-bash"><span class="hljs-built_in">cd</span> distribution/target/rocketmq-4.9.4/rocketmq-4.9.4</span><br></code></pre></td></tr></table></figure><h3 id="Start-Name-Server"><a href="#Start-Name-Server" class="headerlink" title="Start Name Server"></a>Start Name Server</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-built_in">nohup</span> sh bin/mqnamesrv &amp;</span><br><span class="hljs-meta prompt_">  &gt; </span><span class="language-bash"><span class="hljs-built_in">tail</span> -f ~/logs/rocketmqlogs/namesrv.log</span><br>  The Name Server boot success...<br></code></pre></td></tr></table></figure><h3 id="Start-Broker"><a href="#Start-Broker" class="headerlink" title="Start Broker"></a>Start Broker</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-built_in">nohup</span> sh bin/mqbroker -n localhost:9876 &amp;</span><br><span class="hljs-meta prompt_">  &gt; </span><span class="language-bash"><span class="hljs-built_in">tail</span> -f ~/logs/rocketmqlogs/broker.log</span> <br>  The broker[%s, 172.30.30.233:10911] boot success...<br></code></pre></td></tr></table></figure><h3 id="Send-amp-Receive-Messages"><a href="#Send-amp-Receive-Messages" class="headerlink" title="Send &amp; Receive Messages"></a>Send &amp; Receive Messages</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-built_in">export</span> NAMESRV_ADDR=localhost:9876</span><br><span class="hljs-meta prompt_"> &gt; </span><span class="language-bash">sh bin/tools.sh org.apache.rocketmq.example.quickstart.Producer</span><br> SendResult [sendStatus=SEND_OK, msgId= ...<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"> &gt; </span><span class="language-bash">sh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer</span><br><span class="hljs-meta prompt_"> ConsumeMessageThread_%</span><span class="language-bash">d Receive New Messages: [MessageExt...</span><br><br></code></pre></td></tr></table></figure><h3 id="Shutdown-Servers"><a href="#Shutdown-Servers" class="headerlink" title="Shutdown Servers"></a>Shutdown Servers</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">sh bin/mqshutdown broker</span><br>The mqbroker(36695) is running...<br>Send shutdown request to mqbroker(36695) OK<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">sh bin/mqshutdown namesrv</span><br>The mqnamesrv(36664) is running...<br>Send shutdown request to mqnamesrv(36664) OK<br></code></pre></td></tr></table></figure><h3 id="RocketMq-Console"><a href="#RocketMq-Console" class="headerlink" title="RocketMq Console"></a>RocketMq Console</h3><p>已更名为rocketmq-dashboard</p><h4 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">从GitHub上面拉取代码</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> https://github.com/apache/rocketmq-dashboard.git</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> rocketmq-dashboard</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">maven打包</span><br>mvn clean package -Dmaven.test.skip=true<br>java -jar target/rocketmq-dashboard-1.0.1-SNAPSHOT.jar<br><br>or<br><br>mvn spring-boot:run<br></code></pre></td></tr></table></figure><h4 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h4><blockquote><p><code>rocketmq-console/src/main/resources/application.properties</code></p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server.address</span>=<span class="hljs-string">0.0.0.0</span><br><span class="hljs-comment"># server.port=8080</span><br><span class="hljs-comment"># 我这里将8080改成19876了</span><br><span class="hljs-attr">server.port</span>=<span class="hljs-string">19876</span><br><span class="hljs-comment"># …… </span><br><span class="hljs-comment"># 中间省略</span><br><span class="hljs-comment"># ………</span><br><span class="hljs-comment"># 这里是指定Nameserv,也可以不指定，在前端控制台进行指定</span><br><span class="hljs-attr">rocketmq.config.namesrvAddr</span>=<span class="hljs-string">localhost:9876</span><br><span class="hljs-comment"># …… </span><br><span class="hljs-comment"># 后续省略</span><br><span class="hljs-comment"># ………</span><br></code></pre></td></tr></table></figure><h4 id="RocketMq启动"><a href="#RocketMq启动" class="headerlink" title="RocketMq启动"></a>RocketMq启动</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">NettyServerConfig默认端口:10911<br>NameServer默认端口:9876<br><br><span class="hljs-comment"># rocketmq 启动路径</span><br>  /xdfapp/server/rocket/rocketmq-all-4.3.0/distribution/target/apache-rocketmq/bin<br><span class="hljs-comment"># 日志路径</span><br>  /root/logs/rocketmqlogs<br><br><span class="hljs-comment"># 启动NameServer</span><br><span class="hljs-built_in">nohup</span> ./mqnamesrv &amp;<br><span class="hljs-comment"># 启动Broker</span><br><span class="hljs-built_in">nohup</span> ./mqbroker -c ../conf/broker.conf &amp;<br><br><br><span class="hljs-comment"># broker.conf配置</span><br>brokerClusterName = DefaultCluster<br>brokerName = broker-a<br>brokerId = 0<br>deleteWhen = 04<br>fileReservedTime = 48<br>brokerRole = ASYNC_MASTER<br>flushDiskType = ASYNC_FLUSH<br>namesrvAddr=10.60.0.65:9876<br><span class="hljs-comment"># brokerIP1=10.60.0.65</span><br>autoCreateTopicEnable=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># Licensed to the Apache Software Foundation (ASF) under one or more</span><br><span class="hljs-comment"># contributor license agreements.  See the NOTICE file distributed with</span><br><span class="hljs-comment"># this work for additional information regarding copyright ownership.</span><br><span class="hljs-comment"># The ASF licenses this file to You under the Apache License, Version 2.0</span><br><span class="hljs-comment"># (the &quot;License&quot;); you may not use this file except in compliance with</span><br><span class="hljs-comment"># the License.  You may obtain a copy of the License at</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#     http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#  Unless required by applicable law or agreed to in writing, software</span><br><span class="hljs-comment">#  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="hljs-comment">#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="hljs-comment">#  See the License for the specific language governing permissions and</span><br><span class="hljs-comment">#  limitations under the License.</span><br><span class="hljs-attr">​</span><br><span class="hljs-attr">​</span><br><span class="hljs-comment"># 所属集群名字</span><br><span class="hljs-attr">brokerClusterName</span>=<span class="hljs-string">DefaultCluster</span><br><span class="hljs-attr">​</span><br><span class="hljs-comment"># broker 名字，注意此处不同的配置文件填写的不一样，如果在 broker-a.properties 使用: broker-a,</span><br><span class="hljs-comment"># 在 broker-b.properties 使用: broker-b</span><br><span class="hljs-attr">brokerName</span>=<span class="hljs-string">broker-a</span><br><span class="hljs-attr">​</span><br><span class="hljs-comment"># 0 表示 Master，&gt; 0 表示 Slave</span><br><span class="hljs-attr">brokerId</span>=<span class="hljs-string">0</span><br><span class="hljs-attr">​</span><br><span class="hljs-comment"># nameServer地址，分号分割</span><br><span class="hljs-comment"># namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876</span><br><span class="hljs-attr">​</span><br><span class="hljs-comment"># 启动IP,如果 docker 报 com.alibaba.rocketmq.remoting.exception.RemotingConnectException: connect to &lt;192.168.0.120:10909&gt; failed</span><br><span class="hljs-comment"># 解决方式1 加上一句 producer.setVipChannelEnabled(false);，解决方式2 brokerIP1 设置宿主机IP，不要使用docker 内部IP</span><br><span class="hljs-attr">brokerIP1</span>=<span class="hljs-string">192.168.200.129</span><br><span class="hljs-attr">​</span><br><span class="hljs-comment"># 在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span><br><span class="hljs-attr">defaultTopicQueueNums</span>=<span class="hljs-string">4</span><br><span class="hljs-attr">​</span><br><span class="hljs-comment"># 是否允许 Broker 自动创建 Topic，建议线下开启，线上关闭 </span><br><span class="hljs-attr">autoCreateTopicEnable</span>=<span class="hljs-string">true</span><br><span class="hljs-attr">​</span><br><span class="hljs-comment"># 是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span><br><span class="hljs-attr">autoCreateSubscriptionGroup</span>=<span class="hljs-string">true</span><br><span class="hljs-attr">​</span><br><span class="hljs-comment"># Broker 对外服务的监听端口</span><br><span class="hljs-attr">listenPort</span>=<span class="hljs-string">10911</span><br><span class="hljs-attr">​</span><br><span class="hljs-comment"># 删除文件时间点，默认凌晨4点</span><br><span class="hljs-attr">deleteWhen</span>=<span class="hljs-string">04</span><br><span class="hljs-attr">​</span><br><span class="hljs-comment"># 文件保留时间，默认48小时</span><br><span class="hljs-attr">fileReservedTime</span>=<span class="hljs-string">120</span><br><span class="hljs-attr">​</span><br><span class="hljs-comment"># commitLog 每个文件的大小默认1G</span><br><span class="hljs-attr">mapedFileSizeCommitLog</span>=<span class="hljs-string">1073741824</span><br><span class="hljs-attr">​</span><br><span class="hljs-comment"># ConsumeQueue 每个文件默认存 30W 条，根据业务情况调整</span><br><span class="hljs-attr">mapedFileSizeConsumeQueue</span>=<span class="hljs-string">300000</span><br><span class="hljs-attr">​</span><br><span class="hljs-comment"># destroyMapedFileIntervalForcibly=120000</span><br><span class="hljs-comment"># redeleteHangedFileInterval=120000</span><br><span class="hljs-comment"># 检测物理文件磁盘空间</span><br><span class="hljs-attr">diskMaxUsedSpaceRatio</span>=<span class="hljs-string">88</span><br><span class="hljs-comment"># 存储路径</span><br><span class="hljs-comment"># storePathRootDir=/home/ztztdata/rocketmq-all-4.1.0-incubating/store</span><br><span class="hljs-comment"># commitLog 存储路径</span><br><span class="hljs-comment"># storePathCommitLog=/home/ztztdata/rocketmq-all-4.1.0-incubating/store/commitlog</span><br><span class="hljs-comment"># 消费队列存储</span><br><span class="hljs-comment"># storePathConsumeQueue=/home/ztztdata/rocketmq-all-4.1.0-incubating/store/consumequeue</span><br><span class="hljs-comment"># 消息索引存储路径</span><br><span class="hljs-comment"># storePathIndex=/home/ztztdata/rocketmq-all-4.1.0-incubating/store/index</span><br><span class="hljs-comment"># checkpoint 文件存储路径</span><br><span class="hljs-comment"># storeCheckpoint=/home/ztztdata/rocketmq-all-4.1.0-incubating/store/checkpoint</span><br><span class="hljs-comment"># abort 文件存储路径</span><br><span class="hljs-comment"># abortFile=/home/ztztdata/rocketmq-all-4.1.0-incubating/store/abort</span><br><span class="hljs-comment"># 限制的消息大小</span><br><span class="hljs-attr">maxMessageSize</span>=<span class="hljs-string">65536</span><br><span class="hljs-attr">​</span><br><span class="hljs-comment"># flushCommitLogLeastPages=4</span><br><span class="hljs-comment"># flushConsumeQueueLeastPages=2</span><br><span class="hljs-comment"># flushCommitLogThoroughInterval=10000</span><br><span class="hljs-comment"># flushConsumeQueueThoroughInterval=60000</span><br><span class="hljs-attr">​</span><br><span class="hljs-comment"># Broker 的角色</span><br><span class="hljs-comment"># - ASYNC_MASTER 异步复制Master</span><br><span class="hljs-comment"># - SYNC_MASTER 同步双写Master</span><br><span class="hljs-comment"># - SLAVE</span><br><span class="hljs-attr">brokerRole</span>=<span class="hljs-string">ASYNC_MASTER</span><br><span class="hljs-attr">​</span><br><span class="hljs-comment"># 刷盘方式</span><br><span class="hljs-comment"># - ASYNC_FLUSH 异步刷盘</span><br><span class="hljs-comment"># - SYNC_FLUSH 同步刷盘</span><br><span class="hljs-attr">flushDiskType</span>=<span class="hljs-string">ASYNC_FLUSH</span><br><span class="hljs-attr">​</span><br><span class="hljs-comment"># 发消息线程池数量</span><br><span class="hljs-comment"># sendMessageThreadPoolNums=128</span><br><span class="hljs-comment"># 拉消息线程池数量</span><br><span class="hljs-comment"># pullMessageThreadPoolNums=128</span><br><br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h59wbk1b8yj21820l0ab0.jpg" alt="image-20220817173427156"></p><p>RocketMq使用</p><p>在消息存储方面使用顺序写</p><p>在消息发送方面使用零拷贝技术，少了从内核态到用户态的步骤，同时一次只能映射1.5G~2G的数据到虚拟内存，所以RocketMQ默认设置单个CommitLog日志数据文件大小为1G</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h59wzdjz5sj21p10u0tbz.jpg" alt="image-20220817175729240"></p><ul><li>CommitLog: 存储消息的元数据</li><li>ConsumerQueue: 存储消息在CommitLog的索引，按照消息的偏移量来查询消息</li><li>IndexFile: 提供了一种通过key或者时间区间查询消息的方法</li></ul><h3 id="刷盘机制"><a href="#刷盘机制" class="headerlink" title="刷盘机制"></a>刷盘机制</h3><blockquote><p>指的是消息从内存到磁盘</p></blockquote><ul><li>同步刷盘，保证数据不丢失</li><li><strong>异步刷盘，高吞吐量</strong></li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h59x8t1s6fj21670u076m.jpg" alt="image-20220817180635301"></p><h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h59xflsnvfj21g90u0tbm.jpg" alt="image-20220817181308435"></p><h3 id="消息复制"><a href="#消息复制" class="headerlink" title="消息复制"></a>消息复制</h3><ul><li>同步复制，只有master把消息同步到slave，才通知用户写入成功</li><li>异步复制，只要master写入成功，就通知用户成功，可能出现消息的丢失</li><li>配置方式：broker.properties中的brokerRole<ul><li>ASYNC_MASTER 主节点，异步复制</li><li><strong>SYNC_MASTER 主节点，同步复制，保证消息不丢失</strong></li><li>SLAVE 从节点</li></ul></li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h59xo9j383j211l0u076a.jpg" alt="image-20220817182127810"></p><p><strong>建议：异步刷盘+主从同步复制</strong></p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><ul><li>生产者负载均衡：轮询发送，会平均落在不同的Broker的不同的Queue（同一个topic）</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h59yar6xlpj21ji0leacd.jpg" alt="image-20220817184304881"></p><ul><li><p>消费者负载均衡</p><ul><li><p>集群模式，默认就实现了负载均衡，只需要增加消费者就可以达到负载的效果</p><blockquote><p><strong>在集群模式下，一个队列只允许分配给一个消费者，当消费者的数量比队列的数量还多的话，就会出现闲置的消费者</strong></p></blockquote><p>默认算法是：AllocateMessageQueueAveragely</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h59ygldk4qj20wc0o83zn.jpg" alt="image-20220817184838450"></p><p>另一种算法是：AllocateMessageQueueAveragelyByCircle</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h59yiqjbz4j20w80o0ta0.jpg" alt="image-20220817185045079"></p></li><li><p>广播模式</p><blockquote><p><strong>每一个消费者都会消费所有的队列，所有广播模式不属于负载均衡</strong></p></blockquote></li></ul></li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h59yqme13aj20z20oamyt.jpg" alt="image-20220817185816466"></p><h3 id="消息重试"><a href="#消息重试" class="headerlink" title="消息重试"></a>消息重试</h3><blockquote><p>指的是消费者消费消息失败后会重试</p></blockquote><ul><li><p>顺序消息的重试</p><blockquote><p><strong>当出现消费失败的情况时，会无限次数重试(每隔1秒)，应及时进行处理，避免造成消费阻塞</strong></p></blockquote></li><li><p>无序消息的重试</p><blockquote><p>无序消息重试，只针对集群方式生效（默认最多重试16次），依然失败则进入死信队列，而广播模式没有重试机制</p></blockquote></li></ul><p>​<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h59z9j6h3uj21aw0ismyq.jpg" alt="image-20220817191627279"></p><p>无序消费的集群模式重试机制配置方式：</p><p>推荐使用：Action.ReconsumeLater;</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h59zdvgml7j20xu0fswgf.jpg" alt="image-20220817192040478"></p><p>不想重试，配置如下</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h59zgstq62j20y40fodhm.jpg" alt="image-20220817192329498"></p><h3 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h3><blockquote><p>当消息经过重试后依然失败，消息会被放入死信队列</p></blockquote><p>特征：</p><ul><li>不会再被消费者正常消费</li><li>有效期与正常消息相同，均为3天</li><li><strong>死信队列对应的是消费者组</strong>，该消费者组下面的所有topic都会放入同一个死信队列</li></ul><p>如何消费死信队列</p><ul><li>可以在控制台重新发送该消息</li><li>可以创建一个新的消费者，重新消费死信队列中的消息</li></ul><h3 id="生产者与生产者组"><a href="#生产者与生产者组" class="headerlink" title="生产者与生产者组"></a>生产者与生产者组</h3><blockquote><p>消息发送包括同步发送，异步发送，顺序发送，单向发送。</p><p>同步发送，发送过程中处于阻塞状态，直到broker返回消息确认</p><p>异步发送，同步异步回调来接收broker的消息确认</p><p>顺序发送，</p><p>单向发送，发过去就不管了，没有消息确认机制</p></blockquote><blockquote><p>生产者组，同一类Producer的集合，发送同一类消息且发送逻辑一致</p><p>使用场景：如果发送的是事务消息且发送消息之后生产者崩溃了，但事务还没有结束，此时broker会与生产者组的其他Producer完成整个事务的发送</p></blockquote><h3 id="消息生产与消费"><a href="#消息生产与消费" class="headerlink" title="消息生产与消费"></a>消息生产与消费</h3><ul><li><p>顺序消费</p><blockquote><p>生产者通过MessageQueueSelector实现，原理是对传递的参数进行取模或者hash运算，将需要排序的消息发往同一个队列</p><p>当Broker推送消息到消费者时，消费者会通过一个orderly的监听器进行顺序消费</p></blockquote></li><li><p>延迟消息</p><blockquote><p>消息生产者设置messageDelayLevel实现延迟消息，非商业版只能设置18个等级的messageDelayLevel，如下</p><p>原理：18个等级对应着18个延迟消费的队列（系统内置的延迟队列<strong>SCHEDULE_TOPIC_XXXX</strong>），延迟消息不是延迟发送，而是延迟消费</p><p>messageDelayLevel&#x3D;1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h</p></blockquote></li><li><p>批量消息</p><blockquote><ul><li>将消息放到集合进行批量发送，但是批量的消息限制在4m以内</li><li>如果超出4M，可以使用<code>ListSpliter</code>进行拆分成小于4m的集合进行分批发送；同时设置Broker的接收限制为4M以内，即<code>broker.conf</code>中的<code>maxMessageSize</code></li><li>在生产者中的源码中<code>DefaultMQProducer</code>，已经设置了<code>maxMessageSize</code>的大小限制为4M</li></ul></blockquote><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h6841gcjg2j20v80seq6b.jpg" alt="image-20220916075050844"></p></li><li><p>过滤消息</p><ul><li><p>Tag方式的过滤</p><blockquote><p>生产方对消息打上tag</p><p>消费方订阅带有指定tag的消息，实际上过滤是Broker做的</p><p>不适用复杂场景的过滤</p></blockquote></li><li><p>SQL表达式过滤</p><blockquote><p>生产方通过putUserProperty为消息设置各种键值对</p><p>消费方通过mq的sql表达式</p><p>同时设置<code>broker.conf</code>中的<code>enablePropertyFilter=true</code></p></blockquote></li></ul></li></ul><h3 id="消息的推和拉"><a href="#消息的推和拉" class="headerlink" title="消息的推和拉"></a>消息的推和拉</h3><ul><li><p>推模式</p><blockquote><p>推模式指的是broker将消息推给消费者，消费者通过监听器接收消息并消费；</p><p>大部分场景用的都是推模式</p></blockquote></li><li><p>拉模式</p><blockquote><p>拉模式指的是消费者主动向broker拉取消息，编程起来相对复杂，但灵活性高，可以自定义拉去哪些消息</p><p>适用于消息的回溯，比如需要重新消费过去24小时的某些消息，可以使用拉模式</p></blockquote></li></ul><h3 id="消息幂等"><a href="#消息幂等" class="headerlink" title="消息幂等"></a>消息幂等</h3><p>当Broker或者客户端重启、扩缩容时，会触发Rebalance，重新进行负载均衡</p><p>通过业务唯一标识来保证幂等性</p><ul><li>将消费过的消息进行保存，每次消费之前去查一下，如已消费则直接丢弃</li><li>使用分布式锁，每次消费之前去获取锁，来判断是否已经消费过该消息</li></ul><h3 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5j08mwh0zj211a0f1tab.jpg" alt="rocketmq_architecture_1"></p><h4 id="NameServer作用"><a href="#NameServer作用" class="headerlink" title="NameServer作用"></a>NameServer作用</h4><blockquote><ul><li>Broker管理，集群中每一个NameServer节点都会保存一份完整Broker信息，同时，提供心跳检测Broker是否存活</li><li>RouteInfo管理，每个NameServer将保存关于Broker集群的整个路由信息和用于客户端查询的队列信息。</li></ul></blockquote><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5j0o7o5eaj20nz0e0dg6.jpg" alt="rocketmq_architecture_2"></p><h4 id="BrokerServer作用"><a href="#BrokerServer作用" class="headerlink" title="BrokerServer作用"></a>BrokerServer作用</h4><blockquote><p>Broker主要负责消息的存储、投递和查询以及服务高可用保证</p></blockquote><h3 id="部署架构"><a href="#部署架构" class="headerlink" title="部署架构"></a>部署架构</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5j1a0oo87j21350g6jtb.jpg" alt="rocketmq_architecture_3"></p><ul><li>NameServer是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。</li><li>一个Master可以对应多个Slave，但是一个Slave只能对应一个Master，Master与Slave 的对应关系通过指定相同的BrokerName</li><li>BrokerId为0表示Master，非0表示Slave</li><li>Broker与NameServer通过长连接定时注册RouteInfo到NameServer</li><li>&#x3D;&#x3D;<strong>当前RocketMQ版本在部署架构上支持一Master多Slave，但只有BrokerId&#x3D;1的从服务器才会参与消息的读负载。</strong>&#x3D;&#x3D;</li></ul><p>​<strong>Producer</strong></p><ul><li>Producer完全无状态</li><li>Producer与NameServer集群中的其中一个节点（随机选择）建立长连接</li><li>定期从NameServer获取Topic路由信息</li><li>Producer定期想Broker的Master节点发送心跳</li></ul><p>​<strong>Consumer</strong></p><ul><li>Consumer与NameServer集群中的其中一个节点（随机选择）建立长连接</li><li>定期从NameServer获取Topic路由信息</li><li>Consumer定期向Master、Slave发送心跳</li></ul><h3 id="消息存储"><a href="#消息存储" class="headerlink" title="消息存储"></a>消息存储</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5j54b0u61j20vq0owwhr.jpg" alt="rocketmq_design_1"></p><p><strong>CommitLog</strong></p><ul><li>存放的是真正的消息内容</li><li>存储Producer端写入的消息主体内容</li><li>消息主要是顺序写入日志文件（文件长度20），00000000000000000000代表了第一个文件，起始偏移量为0，文件大小为1G&#x3D;1073741824；当第一个文件写满了，第二个文件为00000000001073741824，起始偏移量为1073741824，以此类推。</li></ul><p><strong>ConsumeQueue</strong></p><ul><li>存放的是消息的偏移量信息</li><li>ConsumeQueue是逻辑消费队列</li><li>Consumer可根据ConsumeQueue来查找待消费的消息</li><li>具体存储路径为：$HOME&#x2F;store&#x2F;consumequeue&#x2F;{topic}&#x2F;{queueId}&#x2F;{fileName}</li><li>文件中每一个条目共20个字节，分别为8字节的commitlog物理偏移量、4字节的消息长度、8字节tag hashcode</li><li>每个ConsumeQueue文件大小约5.72M</li></ul><p><strong>IndexFile</strong></p><ul><li>IndexFile（索引文件）**&#x3D;&#x3D;提供了一种可以通过key或时间区间来查询消息的方法&#x3D;&#x3D;**</li><li>Index文件的存储位置是：$HOME&#x2F;store&#x2F;index&#x2F;{fileName}，文件名fileName是以创建时的时间戳命名的</li><li>单个IndexFile文件大小约为400M</li><li>IndexFile的底层存储设计为HashMap结构</li></ul><p>Broker端的后台服务线程—ReputMessageService不停地分发请求并异步构建ConsumeQueue（逻辑消费队列）和IndexFile（索引文件）数据。</p><h3 id="页缓存与内存映射"><a href="#页缓存与内存映射" class="headerlink" title="页缓存与内存映射"></a>页缓存与内存映射</h3><p><strong>页缓存 PageCache</strong></p><ul><li>对于数据的写入，OS会先写入至Cache内，随后通过异步的方式由pdflush内核线程将Cache内的数据刷盘至物理磁盘上。</li><li>对于数据的读取，如果一次读取文件时出现未命中PageCache的情况，OS从物理磁盘上访问读取文件的同时，会顺序对其他相邻块的数据文件进行预读取。</li></ul><p><strong>内存映射</strong></p><ul><li>RocketMQ主要通过MappedByteBuffer对文件进行读写操作。即零拷贝技术</li></ul><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="生产者发送消息"><a href="#生产者发送消息" class="headerlink" title="生产者发送消息"></a>生产者发送消息</h3><h4 id="负载均衡-1"><a href="#负载均衡-1" class="headerlink" title="负载均衡"></a>负载均衡</h4><blockquote><p><code>org.apache.rocketmq.client.latency.MQFaultStrategy#selectOneMessageQueue</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 生产者是如何选择将消息发送到哪个队列的</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">public</span> MessageQueue <span class="hljs-title function_">selectOneMessageQueue</span><span class="hljs-params">(<span class="hljs-keyword">final</span> TopicPublishInfo tpInfo, <span class="hljs-keyword">final</span> String lastBrokerName)</span> &#123;<br>     <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.sendLatencyFaultEnable) &#123;<br>         <span class="hljs-keyword">try</span> &#123;<br>             <span class="hljs-comment">// 去threadLocal获取index，保证线程之间的数据隔离</span><br>             <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> tpInfo.getSendWhichQueue().incrementAndGet();<br>             <span class="hljs-comment">// 遍历需要发送的队列</span><br>             <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; tpInfo.getMessageQueueList().size(); i++) &#123;<br>                 <span class="hljs-comment">// 对index与队列总数进行取模</span><br>                 <span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> Math.abs(index++) % tpInfo.getMessageQueueList().size();<br>                 <span class="hljs-keyword">if</span> (pos &lt; <span class="hljs-number">0</span>)<br>                     pos = <span class="hljs-number">0</span>;<br>                 <span class="hljs-comment">// 确定要发送到哪个队列</span><br>                 <span class="hljs-type">MessageQueue</span> <span class="hljs-variable">mq</span> <span class="hljs-operator">=</span> tpInfo.getMessageQueueList().get(pos);<br>                 <span class="hljs-keyword">if</span> (latencyFaultTolerance.isAvailable(mq.getBrokerName()))<br>                     <span class="hljs-keyword">return</span> mq;<br>             &#125;<br><br>             <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">notBestBroker</span> <span class="hljs-operator">=</span> latencyFaultTolerance.pickOneAtLeast();<br>             <span class="hljs-type">int</span> <span class="hljs-variable">writeQueueNums</span> <span class="hljs-operator">=</span> tpInfo.getQueueIdByBroker(notBestBroker);<br>             <span class="hljs-keyword">if</span> (writeQueueNums &gt; <span class="hljs-number">0</span>) &#123;<br>                 <span class="hljs-keyword">final</span> <span class="hljs-type">MessageQueue</span> <span class="hljs-variable">mq</span> <span class="hljs-operator">=</span> tpInfo.selectOneMessageQueue();<br>                 <span class="hljs-keyword">if</span> (notBestBroker != <span class="hljs-literal">null</span>) &#123;<br>                     mq.setBrokerName(notBestBroker);<br>                     mq.setQueueId(tpInfo.getSendWhichQueue().incrementAndGet() % writeQueueNums);<br>                 &#125;<br>                 <span class="hljs-keyword">return</span> mq;<br>             &#125; <span class="hljs-keyword">else</span> &#123;<br>                 latencyFaultTolerance.remove(notBestBroker);<br>             &#125;<br>         &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>             log.error(<span class="hljs-string">&quot;Error occurred when selecting message queue&quot;</span>, e);<br>         &#125;<br><br>         <span class="hljs-keyword">return</span> tpInfo.selectOneMessageQueue();<br>     &#125;<br><br>     <span class="hljs-keyword">return</span> tpInfo.selectOneMessageQueue(lastBrokerName);<br> &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>MQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RocketMq</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka</title>
    <link href="/2022/07/06/Middleware/MessageQueue/Kafka/"/>
    <url>/2022/07/06/Middleware/MessageQueue/Kafka/</url>
    
    <content type="html"><![CDATA[<h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><ul><li><p>安装</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install kafka<br></code></pre></td></tr></table></figure></li><li><p>启动</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动zk 脚本位于/usr/local/opt/kafka/bin/</span><br>zookeeper-server-start -daemon /usr/local/etc/kafka/zookeeper.properties<br><br><span class="hljs-comment"># 启动kafka 脚本位于/usr/local/opt/kafka/bin/ </span><br>kafka-server-start -daemon  /usr/local/etc/kafka/server.properties<br></code></pre></td></tr></table></figure></li><li><p>创建topic与查看主题信息</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建topic</span><br>kafka-topics --create --topic quickstart-events --bootstrap-server localhost:9092<br><br><span class="hljs-comment"># 2.2以下使用 如下命令，基本已弃用</span><br>kafka-topics --create --topic test-events --zookeeper localhost:2181<br><br><span class="hljs-comment"># 参数说明</span><br><span class="hljs-comment"># kafka节点，集群用逗号隔开</span><br>--bootstrap-server localhost:9092<br><span class="hljs-comment"># 副本数</span><br>--replication-factor 1 <br><span class="hljs-comment"># 指定分区</span><br>--partitions 1<br><br><span class="hljs-comment"># 查看topic信息</span><br>kafka-topics --describe --topic quickstart-events --bootstrap-server localhost:9092<br><br><span class="hljs-comment"># topic信息如下</span><br>Topic: quickstart-eventsTopicId: ldMRGNAoQGOcN0xwH9iZkQPartitionCount: 1ReplicationFactor: 1Configs: segment.bytes=1073741824<br>Topic: quickstart-eventsPartition: 0Leader: 0Replicas: 0Isr: 0<br><br><span class="hljs-comment"># 查看主题列表</span><br>kafka-topics --list --bootstrap-server localhost:9092<br><br><span class="hljs-comment"># 删除主题，不能直接在zk客户端删除，删除后，通过命令还是查询到主题，而且用下面的命令删除会出现异常</span><br>kafka-topics --bootstrap-server localhost:9092 --topic mytest --delete<br></code></pre></td></tr></table></figure></li><li><p>生产消息</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Ctrl+C 取消生产</span><br>➜  ~ kafka-console-producer --topic quickstart-events --bootstrap-server localhost:9092<br>&gt;This is my first event<br>&gt;This is my second event<br><br><br>kafka-console-producer --topic quickstart-events --bootstrap-server 10.60.0.65:6667<br></code></pre></td></tr></table></figure><blockquote><p>当topic存在多个分区时，同时发送的时候没有指定分区，则根据hash算法计算投递到哪个分区，hash(key)%partitionNum，因此保证消息有序性可以通过相同的key来保证</p><p>也可以通过指定partition保证有序性</p></blockquote></li><li><p>生产者同步发送与异步发送</p><p>同步发送，需要等待kafka的ack通知</p><p>异步发送，kafka收到消息后会通过callback通知生产者，&#x3D;&#x3D;<strong>会存在消息丢失</strong>&#x3D;&#x3D;</p><ul><li><p>同步发送的ack配置</p><blockquote><p>ack&#x3D;0 无需任何Broker接收到消息，立刻返回ack</p><p>ack&#x3D;1 多副本的Leader已经收到消息并且数据已经写到本地磁盘，返回ack</p><p>ack&#x3D;-1 集群中所有的Broker都收到了消息并写入磁盘，返回ack</p></blockquote><p>同步的副本数据配置：min.insync.replicas(默认是1，推荐配置大于等于2)，Leader和Follower都算副本</p></li></ul></li><li><p>生产者将消息发送到Broker，并保存到磁盘<code>/usr/local/var/lib/kafka-logs/topic-partition/00000000000000000000.log</code></p></li><li><p>消费消息</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 该命令不会删除消息</span><br><span class="hljs-comment"># 从头消费</span><br>kafka-console-consumer --topic quickstart-events --from-beginning --bootstrap-server localhost:9092<br><br><span class="hljs-comment"># 从offset+1开始消费</span><br>kafka-console-consumer --topic quickstart-events --bootstrap-server localhost:9092<br></code></pre></td></tr></table></figure></li><li><p>消费者自动提交和手动提交offset</p><ol><li>自动提交：消息被消费者poll下来就立即提交offset，会丢消息</li><li>手动提交：消费者消费消息时&#x2F;后，手动提交offset<ul><li>手动同步提交：提交offset后，需要等到Broker确认后返回ack，才能继续向下执行</li><li>手动异步提交：提分offset后，无需等待Broker确认，Broker会通过回调onComplete通知消费者</li></ul></li></ol></li></ul><p>&#x3D;&#x3D;<strong>前者是老版本的用法，0.8以前的kafka，消费的进度(offset)是写在zk中的，所以consumer需要知道zk的地址。后来的版本都统一由broker管理，所以就用bootstrap-server了。</strong>&#x3D;&#x3D;</p><h3 id="单播消息"><a href="#单播消息" class="headerlink" title="单播消息"></a>单播消息</h3><blockquote><p>同一个消费者组中的消费者，只能有一个能接收到同一个topic生产者发送过来的消息</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kafka-console-consumer --topic quickstart-events --bootstrap-server localhost:9092 --consumer-property group.id=testGroup <br></code></pre></td></tr></table></figure><h3 id="多播消息"><a href="#多播消息" class="headerlink" title="多播消息"></a>多播消息</h3><blockquote><p>不同的消费者组订阅同一个topic，那么不同的消费者组中只有一个消费者能收到消息</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">kafka-console-consumer --topic quickstart-events --bootstrap-server localhost:9092 --consumer-property group.id=testGroup1 <br><br>kafka-console-consumer --topic quickstart-events --bootstrap-server localhost:9092 --consumer-property group.id=testGroup2 <br></code></pre></td></tr></table></figure><h3 id="消费者组"><a href="#消费者组" class="headerlink" title="消费者组"></a>消费者组</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看消费者组列表</span><br>kafka-consumer-groups --bootstrap-server localhost:9092 --list<br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出如下</span><br>testGroup<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看某个消费者组的信息</span><br>kafka-consumer-groups --bootstrap-server localhost:9092 --describe --group testGroup<br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出如下</span><br>GROUP           TOPIC             PARTITION  CURRENT-OFFSET  LOG-END-OFFSET  LAG             CONSUMER-ID                                           HOST            CLIENT-ID<br>testGroup       quickstart-events 0          28              28              0               console-consumer-e63230ea-d567-4a2a-8b9c-eb7e0636d9e4 /127.0.0.1      console-consumer<br><span class="hljs-meta prompt_"># </span><span class="language-bash">消费者宕掉的输出</span><br>GROUP           TOPIC             PARTITION  CURRENT-OFFSET  LOG-END-OFFSET  LAG             CONSUMER-ID     HOST            CLIENT-ID<br>testGroup       quickstart-events 0          28              37              9               -               -               -<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">CURRENT-OFFSET 当前已消费的offset位置</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">LOG-END-OFFSET 最新消息所在的offset位置</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">LAG 有多少条消费未消费</span><br></code></pre></td></tr></table></figure><h3 id="主题和分区"><a href="#主题和分区" class="headerlink" title="主题和分区"></a>主题和分区</h3><ol><li>主题topic的作用是将消息分类，根据不同的场景将消息分类存储</li><li>因为kafka的消息时存储在log文件中，如果不进行分区，文件会越来越大，会导致查询和迁移数据十分困难，分区的作用是为了拆分文件，同时分区还能提高读写的吞吐量</li></ol><h3 id="kafka默认主题"><a href="#kafka默认主题" class="headerlink" title="kafka默认主题"></a>kafka默认主题</h3><p>kafka会自动创建一个<code>__consumer_offsets</code>的主题，该主题的作用是记录其他主题的offset</p><ul><li>默认50个分区（可修改），提高并发</li><li>消费者消费消息后会上报offset</li><li>提交到哪个分区是根据hash算法实现，hash(consumerGroupId)%__consumer_offsets分区数</li><li>提交的内容是，key:consumerGroupId+topic+partition，value:当前offset的值</li></ul><h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><h4 id="jconsole"><a href="#jconsole" class="headerlink" title="jconsole"></a>jconsole</h4><p>监控到 Lag 越来越大，说明消费者程序变得越来越慢了，至少是追不上生产者程序了</p><p>一旦你监测到 Lead 越来越小，甚至是快接近于 0 了，你就一定要小心了，这可能预示着消费者端要丢消息了（因为消息保存有时限，说明消息最近一直未被消费）。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3xfr5q7xyj20zy0u0gpo.jpg" alt="image-20220706193410314"></p><h4 id="Kafka-eagle"><a href="#Kafka-eagle" class="headerlink" title="Kafka-eagle"></a>Kafka-eagle</h4><ol><li><p>下载地址：<a href="http://download.kafka-eagle.org/">http://download.kafka-eagle.org/</a></p></li><li><p>配置环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &#x27;export KE_HOME=/Users/unclebryan/DevTools/efak-web-2.1.0&#x27; &gt;&gt; ~/.zshrc<br>echo &#x27;export PATH=$PATH:$KE_HOME/bin&#x27; &gt;&gt; ~/.zshrc<br>source ~/.zshrc<br></code></pre></td></tr></table></figure></li><li><p>修改配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 修改zk配置</span><br><span class="hljs-attr">efak.zk.cluster.alias</span>=<span class="hljs-string">cluster1</span><br><span class="hljs-attr">cluster1.zk.list</span>=<span class="hljs-string">localhost:2181</span><br><span class="hljs-comment">#修改mysql配置 数据库会自动创建</span><br><span class="hljs-attr">efak.driver</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-attr">efak.url</span>=<span class="hljs-string">jdbc:mysql://127.0.0.1:3306/ke?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull</span><br><span class="hljs-attr">efak.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">efak.password</span>=<span class="hljs-string">123456</span><br></code></pre></td></tr></table></figure></li><li><p>启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">ke.sh start<br><br>* EFAK Service has started success.<br>* Welcome, Now you can visit &#x27;http://192.168.0.172:8048&#x27;<br>* Account:admin ,Password:123456<br></code></pre></td></tr></table></figure></li></ol><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>kafka全局配置 &#x2F;usr&#x2F;local&#x2F;etc&#x2F;kafka&#x2F;server.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">broker.id</span>=<span class="hljs-string">0</span><br><span class="hljs-comment"># The address the socket server listens on. If not configured, the host name will be equal to the value of</span><br><span class="hljs-comment"># java.net.InetAddress.getCanonicalHostName(), with PLAINTEXT listener name, and port 9092.</span><br><span class="hljs-comment">#   FORMAT:</span><br><span class="hljs-comment">#     listeners = listener_name://host_name:port</span><br><span class="hljs-comment">#   EXAMPLE:</span><br><span class="hljs-comment">#     listeners = PLAINTEXT://your.host.name:9092</span><br><span class="hljs-comment">#listeners=PLAINTEXT://:9092</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># The number of threads that the server uses for receiving requests from the network and sending responses to the network</span><br><span class="hljs-attr">num.network.threads</span>=<span class="hljs-string">3</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># The number of threads that the server uses for processing requests, which may include disk I/O</span><br><span class="hljs-attr">num.io.threads</span>=<span class="hljs-string">8</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># The send buffer (SO_SNDBUF) used by the socket server</span><br><span class="hljs-attr">socket.send.buffer.bytes</span>=<span class="hljs-string">102400</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># The receive buffer (SO_RCVBUF) used by the socket server</span><br><span class="hljs-attr">socket.receive.buffer.bytes</span>=<span class="hljs-string">102400</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># The maximum size of a request that the socket server will accept (protection against OOM)</span><br><span class="hljs-attr">socket.request.max.bytes</span>=<span class="hljs-string">104857600</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 消息存储目录</span><br><span class="hljs-attr">log.dirs</span>=<span class="hljs-string">/usr/local/var/lib/kafka-logs</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># the brokers.</span><br><span class="hljs-attr">num.partitions</span>=<span class="hljs-string">1</span><br><span class="hljs-attr">num.recovery.threads.per.data.dir</span>=<span class="hljs-string">1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 副本数</span><br><span class="hljs-attr">offsets.topic.replication.factor</span>=<span class="hljs-string">1</span><br><span class="hljs-attr">transaction.state.log.replication.factor</span>=<span class="hljs-string">1</span><br><span class="hljs-attr">transaction.state.log.min.isr</span>=<span class="hljs-string">1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># The number of messages to accept before forcing a flush of data to disk</span><br><span class="hljs-comment">#log.flush.interval.messages=10000</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># The maximum amount of time a message can sit in a log before we force a flush</span><br><span class="hljs-comment">#log.flush.interval.ms=1000</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 消息保存的时间限制，超出后会删除</span><br><span class="hljs-attr">log.retention.hours</span>=<span class="hljs-string">168</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># A size-based retention policy for logs. Segments are pruned from the log unless the remaining</span><br><span class="hljs-comment"># segments drop below log.retention.bytes. Functions independently of log.retention.hours.</span><br><span class="hljs-comment"># 消息保存的容量限制，超出后会删除</span><br><span class="hljs-attr">log.retention.bytes</span>=<span class="hljs-string">1073741824</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># The maximum size of a log segment file. When this size is reached a new log segment will be created.</span><br><span class="hljs-attr">log.segment.bytes</span>=<span class="hljs-string">1073741824</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># The interval at which log segments are checked to see if they can be deleted according</span><br><span class="hljs-comment"># to the retention policies</span><br><span class="hljs-attr">log.retention.check.interval.ms</span>=<span class="hljs-string">300000</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># server. e.g. &quot;127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002&quot;.</span><br><span class="hljs-comment"># You can also append an optional chroot string to the urls to specify the</span><br><span class="hljs-comment"># root directory for all kafka znodes.</span><br><span class="hljs-attr">zookeeper.connect</span>=<span class="hljs-string">localhost:2181</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># Timeout in ms for connecting to zookeeper</span><br><span class="hljs-attr">zookeeper.connection.timeout.ms</span>=<span class="hljs-string">18000</span><br><br><span class="hljs-attr">group.initial.rebalance.delay.ms</span>=<span class="hljs-string">0</span><br><br></code></pre></td></tr></table></figure><p>zk配置 zookeeper.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># the directory where the snapshot is stored.</span><br><span class="hljs-attr">dataDir</span>=<span class="hljs-string">/usr/local/var/lib/zookeeper</span><br><span class="hljs-comment"># the port at which the clients will connect</span><br><span class="hljs-attr">clientPort</span>=<span class="hljs-string">2181</span><br><span class="hljs-comment"># disable the per-ip limit on the number of connections since this is a non-production config</span><br><span class="hljs-attr">maxClientCnxns</span>=<span class="hljs-string">0</span><br><span class="hljs-comment"># Disable the adminserver by default to avoid port conflicts.</span><br><span class="hljs-comment"># Set the port to something non-conflicting if choosing to enable this</span><br><span class="hljs-attr">admin.enableServer</span>=<span class="hljs-string">false</span><br><span class="hljs-comment"># admin.serverPort=8080</span><br></code></pre></td></tr></table></figure><h3 id="Kafka整合SpringBoot"><a href="#Kafka整合SpringBoot" class="headerlink" title="Kafka整合SpringBoot"></a>Kafka整合SpringBoot</h3><p>&#x3D;&#x3D;<strong>下图的消费者，其实是poll了一批数据，针对的是每一条数据的操作</strong>&#x3D;&#x3D;</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3xpe4hggdj214o08q75f.jpg" alt="image-20220707010746932"></p><h3 id="开发环境KAFKA"><a href="#开发环境KAFKA" class="headerlink" title="开发环境KAFKA"></a>开发环境KAFKA</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh root@10.60.0.65<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">监控</span><br>http://10.60.0.65:8048<br><br>bootstrap-servers 10.60.0.65:6667,10.60.0.66:6667,10.60.0.67:6667<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>MQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDD领域驱动设计</title>
    <link href="/2022/06/06/DDD/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    <url>/2022/06/06/DDD/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="DDD领域驱动设计"><a href="#DDD领域驱动设计" class="headerlink" title="DDD领域驱动设计"></a>DDD领域驱动设计</h2><h4 id="数据驱动设计流程"><a href="#数据驱动设计流程" class="headerlink" title="数据驱动设计流程"></a>数据驱动设计流程</h4><ol><li>需求分析</li><li>数据建模（ER图）</li><li>建库建表（写DAO)</li><li>编写业务逻辑</li></ol><p>弊端：很难重用、</p><h4 id="领域驱动设计流程"><a href="#领域驱动设计流程" class="headerlink" title="领域驱动设计流程"></a>领域驱动设计流程</h4><ol><li>需求分析，有规范，使用统一语言</li></ol><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ylj1g43dj21cc0u00uo.jpg" alt="image-20220606161912443"></p><ol start="2"><li><p>领域分析——领域边界划分，边界的划分标准是业务</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ylk691lsj21h50u00vt.jpg" alt="image-20220606162020157"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ylohgyguj21dy0u040g.jpg" alt="image-20220606162435773"></p></li></ol><p>为了保证领域的内聚性更强，会对领域采取保护手段，包括ACL、OHS、PL</p><p>ACL：接口层面的定义，通过适配器、桥接模式等，</p><p>OHS、PL：应用层</p><p>领域建模</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2yojp64g0j21mi0u077h.jpg" alt="image-20220606180346934"></p><p>领域对象</p><ol><li>Bounded Context</li><li>Aggregate：聚合根，是一个大对象，包含多个Entities、多个Value Object共同组成</li><li>Value Object： 无状态的值对象</li><li>Entities：有唯一标识且有状态的对象</li><li>Services：在Entities无法满足的情况下使用，只操作无状态的数据</li><li>DomainEvents: 领域事件</li><li>Factories：生产Entities等</li><li>Repositoroies：资源，入库操作</li></ol><p>核心业务逻辑</p><p>技术实现细节</p><p>领域驱动中关心业务的流转，业务指的是从订单-&gt;库存-&gt;支付，类似这样的是属于业务；比如，查询订单、查询库存，这些操作不叫业务。</p><h3 id="COLA框架"><a href="#COLA框架" class="headerlink" title="COLA框架"></a>COLA框架</h3><p>CQRS（Command Query</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2yomg8ya0j21gj0u0td7.jpg" alt="image-20220606180623948"> </p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2yonmh44mj21i00u0n1q.jpg" alt="image-20220606180731780"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2yopibz5ij21h50u00wa.jpg" alt="image-20220606180920564"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2yp8i9vjyj21000g575m.jpg" alt="image-20220606182738657"></p><h3 id="六边形架构"><a href="#六边形架构" class="headerlink" title="六边形架构"></a>六边形架构</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2yp9vba0gj211n0g7jtk.jpg" alt="image-20220606182856085"></p><h3 id="洋葱架构"><a href="#洋葱架构" class="headerlink" title="洋葱架构"></a>洋葱架构</h3><p>纵向架构+六边形横向架构相结合</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ypd6tseej213l0fmgow.jpg" alt="image-20220606183208041"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ypduwu5uj20pa0fzgo5.jpg" alt="image-20220606183246117"></p><h3 id="分层架构与DDD整合"><a href="#分层架构与DDD整合" class="headerlink" title="分层架构与DDD整合"></a>分层架构与DDD整合</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ypffncxyj215m0io76l.jpg" alt="image-20220606183418050"></p><h3 id="落地框架-COLA"><a href="#落地框架-COLA" class="headerlink" title="落地框架-COLA"></a>落地框架-COLA</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2ypgtngn7j20mi0gwq4l.jpg" alt="image-20220606183538241"></p><h3 id="微服务拆分"><a href="#微服务拆分" class="headerlink" title="微服务拆分"></a>微服务拆分</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2yprtxckkj20r30j60th.jpg" alt="image-20220606184613350"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2yprd4qf8j20vm0k6jsn.jpg" alt="image-20220606184545801"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2zhd93deaj20w30u0769.jpg" alt="image-20220607104056597"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2zhg96gttj21lw0u0tcb.jpg" alt="image-20220607104348232"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2zil8n2x1j21j40u0n1u.jpg" alt="image-20220607112314611"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2zir9ffi8j21qh0u0jx3.jpg" alt="image-20220607112858273"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2zizrg5irj21yj0u07b7.jpg" alt="image-20220607113712361"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2zj0f5jhqj21w80u0n40.jpg" alt="image-20220607113749800"></p><p>![image-20220608000959856](..&#x2F;..&#x2F;..&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220608000959856.png)</p><p>![image-20220608001139853](..&#x2F;..&#x2F;..&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220608001139853.png)</p>]]></content>
    
    
    
    <tags>
      
      <tag>DDD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/16/Middleware/Zookeeper%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/05/16/Middleware/Zookeeper%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="Zookeeper学习笔记"><a href="#Zookeeper学习笔记" class="headerlink" title="Zookeeper学习笔记"></a>Zookeeper学习笔记</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0xzy2xkchj21f70u0ag8.jpg" alt="image-20220404211140955"></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># The number of milliseconds of each tick</span><br><span class="hljs-comment"># 每次的心跳时间，指的是客户端与服务端或者服务端与服务端，如果超过2秒钟，说明连接断开</span><br><span class="hljs-attr">tickTime</span>=<span class="hljs-string">2000</span><br><span class="hljs-comment"># The number of ticks that the initial </span><br><span class="hljs-comment"># synchronization phase can take</span><br><span class="hljs-comment"># 初始化时的心跳个数，指的是第一次Leader与Follower建立连接时的通信心跳个数，即20秒，如果超过20秒则表示建立连接失败</span><br><span class="hljs-attr">initLimit</span>=<span class="hljs-string">10</span><br><span class="hljs-comment"># The number of ticks that can pass between </span><br><span class="hljs-comment"># sending a request and getting an acknowledgement</span><br><span class="hljs-comment"># 指的是非第一次通信时，Leader与Follower建立连接时的通信心跳个数</span><br><span class="hljs-attr">syncLimit</span>=<span class="hljs-string">5</span><br><span class="hljs-comment"># the directory where the snapshot is stored.</span><br><span class="hljs-comment"># do not use /tmp for storage, /tmp here is just </span><br><span class="hljs-comment"># example sakes.</span><br><span class="hljs-comment"># zookeeper数据目录，不能存在tmp目录，Linux会定期回收tmp里的文件</span><br><span class="hljs-attr">dataDir</span>=<span class="hljs-string">/Users/unclebryan/DevTools/apache-zookeeper-3.7.0-bin/data</span><br><span class="hljs-comment"># 日志文件</span><br><span class="hljs-attr">dataLogDir</span>=<span class="hljs-string">/Users/unclebryan/DevTools/apache-zookeeper-3.7.0-bin/logs</span><br><span class="hljs-comment"># the port at which the clients will connect</span><br><span class="hljs-comment"># 客户端与服务端通信端口</span><br><span class="hljs-attr">clientPort</span>=<span class="hljs-string">2181</span><br><span class="hljs-comment"># the maximum number of client connections.</span><br><span class="hljs-comment"># increase this if you need to handle more clients</span><br><span class="hljs-comment">#maxClientCnxns=60</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Be sure to read the maintenance section of the </span><br><span class="hljs-comment"># administrator guide before turning on autopurge.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The number of snapshots to retain in dataDir</span><br><span class="hljs-comment">#autopurge.snapRetainCount=3</span><br><span class="hljs-comment"># Purge task interval in hours</span><br><span class="hljs-comment"># Set to &quot;0&quot; to disable auto purge feature</span><br><span class="hljs-comment">#autopurge.purgeInterval=1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">## Metrics Providers</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># https://prometheus.io Metrics Exporter</span><br><span class="hljs-comment">#metricsProvider.className=org.apache.zookeeper.metrics.prometheus.PrometheusMetricsProvider</span><br><span class="hljs-comment">#metricsProvider.httpPort=7000</span><br><span class="hljs-comment">#metricsProvider.exportJvmInfo=true</span><br><br></code></pre></td></tr></table></figure><h4 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h4><blockquote><p>每一个节点都要修改</p><ol><li>在zk的数据目录新建一个myid文件，输入myid的值</li><li>在zoo.cfg中加入集群配置信息，如下</li></ol></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 集群模式 1代表myid,2888是Follower与Leader的交换端口，3888是选举端口</span><br>server.1=unclebryan01:2888:3888<br>server.2=unclebryan02:2888:3888<br>server.3=unclebryan03:2888:3888<br><br><span class="hljs-comment"># ps. 记得关闭防火墙</span><br>1. firewall-cmd --reload                  <span class="hljs-comment">#重启firewall</span><br>2. firewall-cmd  --state                  <span class="hljs-comment">#查看防火墙状态</span><br>3. systemctl start firewalld.service      <span class="hljs-comment">#开启firewall</span><br>4. systemctl stop firewalld.service       <span class="hljs-comment">#停止firewall</span><br>5. systemctl <span class="hljs-built_in">disable</span> firewalld.service    <span class="hljs-comment">#禁止firewall开机启动</span><br><br><span class="hljs-comment"># 分别启动zk服务</span><br>zkServer.sh start<br>zkServer.sh status 查看状态<br></code></pre></td></tr></table></figure><h4 id="客户端操作"><a href="#客户端操作" class="headerlink" title="客户端操作"></a>客户端操作</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动客户端</span><br>zkCli.sh -server unclebryan01:2181<br></code></pre></td></tr></table></figure><h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -s /<br><br>[zookeeper]<br><span class="hljs-comment"># 创建节点时的事务id</span><br>cZxid = 0x0<br>ctime = Thu Jan 01 08:00:00 CST 1970<br><span class="hljs-comment"># 最后更新的事务id</span><br>mZxid = 0x0<br>mtime = Thu Jan 01 08:00:00 CST 1970<br><span class="hljs-comment"># 最后更新的子节点的事务id</span><br>pZxid = 0x0<br><span class="hljs-comment"># 子节点的版本号，即子节点的修改次数</span><br>cversion = -1<br><span class="hljs-comment"># 数据版本号</span><br>dataVersion = 0<br><span class="hljs-comment"># 访问控制列表的版本号</span><br>aclVersion = 0<br><span class="hljs-comment"># 临时节点的拥有者的sessionid，如果不是临时节点则为0</span><br>ephemeralOwner = 0x0<br><span class="hljs-comment"># 数据的长度</span><br>dataLength = 0<br><span class="hljs-comment"># 子节点个数</span><br>numChildren = 1<br><br><span class="hljs-comment"># 永久无序</span><br>create /node1 node1<br><span class="hljs-comment"># 永久有序，序号由父节点决定 真正的节点名为节点名+00000001....</span><br>create -s /node2 node2 <br><br><span class="hljs-comment"># 临时无序</span><br>create -e /node3 node3<br><span class="hljs-comment"># 临时有序，序号由父节点决定 真正的节点名为节点名+00000001....</span><br>create -e -s /node4 node4<br><br><br><span class="hljs-comment"># 获取节点信息</span><br>get -s /node1<br><br><br><span class="hljs-comment"># 单节点删除</span><br>delete /node1/n1<br><br><span class="hljs-comment"># 删除整个节点，包括子节点</span><br>deleteall /node1<br></code></pre></td></tr></table></figure><h4 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h4><ul><li><p>持久的</p><blockquote><p>断开连接不删除</p></blockquote></li><li><p>临时的</p><blockquote><p>客户端与服务端断开连接就删除临时节点</p></blockquote></li><li><p>有序的</p></li><li><p>无序的</p></li></ul><h4 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h4><blockquote><p>注意：监听是不能重复监听，需要重复监听就需要重复watch</p></blockquote><ul><li><p>监听节点值的变化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 通过某个客户端设置监听的节点</span><br>get -w /node1<br><br><span class="hljs-comment">#在其他客户端修改节点值</span><br><span class="hljs-built_in">set</span> /node1 <span class="hljs-built_in">test</span><br><br><br><span class="hljs-comment"># 监听客户端收到如下通知</span><br>WATCHER::<br><br>WatchedEvent state:SyncConnected <span class="hljs-built_in">type</span>:NodeDataChanged path:/node1<br><br></code></pre></td></tr></table></figure></li><li><p>监听子节点节点数的变化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 通过某个客户端设置监听的节点</span><br><span class="hljs-built_in">ls</span> -w /node1<br><br><span class="hljs-comment"># 当有新增或者删除节点时，客户端会收到如下通知</span><br>WATCHER::<br><br>WatchedEvent state:SyncConnected <span class="hljs-built_in">type</span>:NodeChildrenChanged path:/node1<br><br></code></pre></td></tr></table></figure></li></ul><h4 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h4><ul><li><p>首次启动集群</p><blockquote><p>服务器1启动</p><ul><li>投自己一票</li><li>此时集群中只有一个节点，不进行选票传递</li><li>判断自己的选票有没有大于集群中的半数节点，即是否大于3，不大于进入LOOKING状态</li></ul><p>服务器2启动</p><ul><li>投自己一票</li><li>进行选票传递，服务器1的myid小于服务器2的myid，服务器1将选票传递给服务器2，此时服务器1的选票为0，服务器2的选票为2</li><li>判断自己的选票有没有大于集群中的半数节点，即是否大于3，不大于进入LOOKING状态</li></ul><p>服务器3启动</p><ul><li>投自己一票</li><li>进行选票传递，服务器2的myid小于服务器3的myid，服务器2将选票传递给服务器3，此时服务器1、2的选票均为0，服务器3的选票为3</li><li>判断自己的选票有没有大于集群中的半数节点，即是否大于3，大于3，选举成功，此时服务器3是Leader节点，状态由LOOKING变为LEADING；服务器1&#x2F;2自动变为Follower节点，状态由LOOKING变为FOLLOWING</li></ul><p>服务器4启动</p><ul><li>投自己一票</li><li>此时集群中1&#x2F;2&#x2F;3服务器已经不再是LOOKING状态，服务器4自动变为Follower</li></ul><p>服务器5启动</p><ul><li>投自己一票</li><li>此时集群中1&#x2F;2&#x2F;3&#x2F;4服务器已经不再是LOOKING状态，服务器5自动变为Follower</li></ul></blockquote></li><li><p>非第一次启动</p><blockquote><p>当服务器5无法与Leader保持连接时，会发起一次选举</p><ul><li><p>Leader正常，只是服务器5无法与Leader保持连接，则继续尝试连接Leader</p></li><li><p>Leader确实挂了，则进入选举</p><p>假如当前集群中SID分别为1、2、3、4、5，ZXID分别为8、8、8、7、7，并且SID为3的服务器为Leader；此时服务器3与5突然挂了，需要进行Leader重新选举，流程如下：</p><ul><li>1、2、4进行Leader选举，依次比较Epoch、ZXID、SID，大的成为Leader</li><li>此时1、2、4的数据分别为1 8 1、1 8 2、1 7 4，所以服务器2为新的Leader</li></ul></li></ul></blockquote></li></ul><h4 id="集群启动脚本"><a href="#集群启动脚本" class="headerlink" title="集群启动脚本"></a>集群启动脚本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-keyword">case</span> <span class="hljs-variable">$1</span> <span class="hljs-keyword">in</span><br><span class="hljs-string">&quot;start&quot;</span>)&#123;<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> unclebryan01 unclebryan02 unclebryan03<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> -----------zk <span class="hljs-variable">$i</span> 启动----------------<br>ssh <span class="hljs-variable">$i</span> <span class="hljs-string">&quot;/usr/local/software/zookeeper-3.5.7/bin/zkServer.sh start&quot;</span><br><span class="hljs-keyword">done</span><br>&#125;<br>;;<br><br><span class="hljs-string">&quot;stop&quot;</span>)&#123;<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> unclebryan01 unclebryan02 unclebryan03<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> -----------zk <span class="hljs-variable">$i</span> 停止----------------<br>ssh <span class="hljs-variable">$i</span> <span class="hljs-string">&quot;/usr/local/software/zookeeper-3.5.7/bin/zkServer.sh stop&quot;</span><br><span class="hljs-keyword">done</span><br>&#125;<br>;;<br><br><br><span class="hljs-string">&quot;status&quot;</span>)&#123;<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> unclebryan01 unclebryan02 unclebryan03<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">echo</span> -----------zk <span class="hljs-variable">$i</span> 状态----------------<br>ssh <span class="hljs-variable">$i</span> <span class="hljs-string">&quot;/usr/local/software/zookeeper-3.5.7/bin/zkServer.sh status&quot;</span><br><span class="hljs-keyword">done</span><br>&#125;<br>;;<br><span class="hljs-keyword">esac</span><br></code></pre></td></tr></table></figure><p>PS. 如果出现JAVA_HOME is not set and java could not be found in PATH，请修改zkEnv.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在文件的最前面增加javahome路径</span><br><span class="hljs-built_in">export</span> JAVA_HOME=<span class="hljs-string">&quot;/usr/local/software/jdk1.8.0_311&quot;</span><br></code></pre></td></tr></table></figure><h4 id="写数据流程"><a href="#写数据流程" class="headerlink" title="写数据流程"></a>写数据流程</h4><ul><li>客户端连接的是Leader节点</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0z6450qfkj21dv0u0gno.jpg" alt="image-20220405213054290"></p><ul><li><p>客户端连接的是Follower节点</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0z65zhsnej220r0u00vn.jpg" alt="image-20220405213243774"></p></li></ul><h4 id="场景应用"><a href="#场景应用" class="headerlink" title="场景应用"></a>场景应用</h4><ul><li><p>服务的动态上下线</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0z6aqsdj8j21nw0u0gqe.jpg" alt="image-20220405213715307"></p></li><li><p>分布式锁</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0z6gm3tw6j21sr0u0dka.jpg" alt="image-20220405214256648"></p></li></ul><blockquote><p>zk实现的分布式锁请使用curator框架</p><p>官网地址：<a href="https://curator.apache.org/">https://curator.apache.org/</a></p></blockquote><h4 id="集群zk的节点数"><a href="#集群zk的节点数" class="headerlink" title="集群zk的节点数"></a>集群zk的节点数</h4><blockquote><ol><li>安装奇数台</li><li>生产经验值：<ol><li>10台服务器，安装3台zk</li><li>20台服务器，安装5台zk</li><li>100台服务器，安装11台zk</li><li>200台服务器，安装11台zk</li></ol></li><li>服务器台数多，好处是提高稳定性，坏处是通信延迟</li></ol></blockquote><h4 id="zookeeper一致性问题"><a href="#zookeeper一致性问题" class="headerlink" title="zookeeper一致性问题"></a>zookeeper一致性问题</h4><h5 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a>Paxos算法</h5><p>角色：</p><p>Proposer（提案者），Acceptor（接收者）、Learner（学习者）；每个节点可以身兼数职</p><p>三个阶段：</p><ol><li>准备阶段<ul><li>Proposer向Acceptor发出Propose请求Promise（许可），无需携带提案内容</li><li>Acceptor向Proposer发送同意此提案</li></ul></li><li>Accept接收阶段<ul><li>Proposer收到超过半数的Acceptor许可后，向Acceptor发出正式Propose</li><li>Acceptor接收到提案后进行Accept处理</li></ul></li><li>Lean阶段<ul><li>Proposer将最终的提案发送给所有的Learners</li></ul></li></ol><p>存在的问题：多个提案者可能出现迟迟无法达成一致的问题，导致性能降低</p><h5 id="ZAB算法"><a href="#ZAB算法" class="headerlink" title="ZAB算法"></a>ZAB算法</h5><p>借鉴Paxos算法，只有一个提案者</p><p>包含两种模式：消息广播、崩溃恢复</p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><ol><li><p>找到启动入口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">zkServer.sh start<br>ZOOMAIN=<span class="hljs-string">&quot;org.apache.zookeeper.server.quorum.QuorumPeerMain&quot;</span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Kafka</title>
    <link href="/2022/05/16/Middleware/MessageQueue/RabbitMq/"/>
    <url>/2022/05/16/Middleware/MessageQueue/RabbitMq/</url>
    
    <content type="html"><![CDATA[<h1 id="RabbitMq"><a href="#RabbitMq" class="headerlink" title="RabbitMq"></a>RabbitMq</h1><h4 id="Erlang安装"><a href="#Erlang安装" class="headerlink" title="Erlang安装"></a>Erlang安装</h4><p><a href="https://www.erlang-solutions.com/downloads/">https://www.erlang-solutions.com/downloads/</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#运行Package Cloud提供的RabbitMQ Server快速安装脚本</span><br>curl -s https://packagecloud.io/install/repositories/rabbitmq/rabbitmq-server/script.rpm.sh | sudo bash<br><br><span class="hljs-comment">#运行Package Cloud提供Erlang环境快速安装脚本</span><br>curl -s https://packagecloud.io/install/repositories/rabbitmq/erlang/script.rpm.sh | sudo bash<br><br><span class="hljs-comment">#使用yum安装Erlang环境</span><br>yum  -y install erlang<br><br><span class="hljs-comment">#安装socat, logrotate依赖</span><br>  yum install socat logrotate -y<br><br><span class="hljs-comment">#使用yum安装RabbitMQ Server</span><br>yum install -y rabbitmq-server<br><br></code></pre></td></tr></table></figure><p>为什么Rabbitmq是基于channel发送消息而不是基 于连接？</p><p>因为连接需要三次握手和四次挥手，会很慢</p><h4 id="消息模式"><a href="#消息模式" class="headerlink" title="消息模式"></a>消息模式</h4><blockquote><p>所有的模式队列与交换机一定要建立绑定关系，如果没有指明交换机，会走一个默认的交换机，默认交换机是direct模式</p></blockquote><h5 id="1-简单模式"><a href="#1-简单模式" class="headerlink" title="1. 简单模式"></a>1. 简单模式</h5><blockquote><p>默认交换机</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1mead9wbsj208002sq2t.jpg" alt="img"></p><h5 id="2-工作队列模式"><a href="#2-工作队列模式" class="headerlink" title="2. 工作队列模式"></a>2. 工作队列模式</h5><blockquote><p>默认交换机</p><ul><li>轮训模式，轮训分发，可以自动ack，但是建议使用手动ack</li><li>公平分发，能者多劳，必须手动ack</li></ul></blockquote><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1meb8nul3j2098033aa0.jpg" alt="img"></p><h5 id="3-发布订阅模式-fanout"><a href="#3-发布订阅模式-fanout" class="headerlink" title="3. 发布订阅模式 fanout"></a>3. 发布订阅模式 fanout</h5><blockquote><p>需要指定交换机</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1mebn8l9rj2098033mx4.jpg" alt="img"></p><h5 id="4-Routing模式（Direct模式）"><a href="#4-Routing模式（Direct模式）" class="headerlink" title="4. Routing模式（Direct模式）"></a>4. Routing模式（Direct模式）</h5><blockquote><p>需要指定交换机和路由key</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1mecaklb6j20bc04r74c.jpg" alt="img"></p><h5 id="5-Topic模式"><a href="#5-Topic模式" class="headerlink" title="5. Topic模式"></a>5. Topic模式</h5><blockquote><p>需要指定交换机和路由key</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1meeihy1lj20bs04rq30.jpg" alt="img"></p><blockquote><p>‘#’ : 匹配一个或多个词</p><p>‘*’ : 匹配不多不少恰好1个词</p><p>item.# ：能够匹配 item.insert.abc 或者 item.insert</p><p>item.* ：只能匹配 item.insert</p></blockquote><h5 id="6-RPC模式"><a href="#6-RPC模式" class="headerlink" title="6. RPC模式"></a>6. RPC模式</h5><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1mefmxo8ij20g005kdg2.jpg" alt="img"></p><h4 id="交换机类型"><a href="#交换机类型" class="headerlink" title="交换机类型"></a>交换机类型</h4><p>direct</p><p>fanout</p><p>topic</p><p>headers</p>]]></content>
    
    
    <categories>
      
      <category>MQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RabbitMq</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/16/Middleware/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E4%B8%8EJava%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E8%B7%B5/"/>
    <url>/2022/05/16/Middleware/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E4%B8%8EJava%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="第6章-消息中间件"><a href="#第6章-消息中间件" class="headerlink" title="第6章 消息中间件"></a>第6章 消息中间件</h2><p><strong>定义</strong>：面向消息的系统（消息中间件）是在分布式系统中完成消息的发送和接收的基础软件。</p><h3 id="6-2-1-如何解决消息发送一致性"><a href="#6-2-1-如何解决消息发送一致性" class="headerlink" title="6.2.1 如何解决消息发送一致性"></a>6.2.1 如何解决消息发送一致性</h3><p>消息发送一致性是指产生消息的业务动作与消息发送的一致。就是说，如果业务操作成功了，那么由这个业务操作产生的消息一定要发送出去。如果业务行为没有发生或者失败，那么就不应该把消息发送出去。</p><h4 id="6-2-1-3-JMS解决方案"><a href="#6-2-1-3-JMS解决方案" class="headerlink" title="6.2.1.3 JMS解决方案"></a>6.2.1.3 JMS解决方案</h4><p>在JMS的API中，有提供以XA开头的接口，它们其实就是支持XA协议的接口。JMS中定义的XA系列的接口就是为了实现分布式事务的支持。</p><p>但是引入分布式事务会带来如下问题：</p><ul><li>会带来一些开销并增加复杂性</li><li>对业务操作有限制，要求业务操作的资源必须支持 XA 协议，才能够与发送消息一起来做分布式事务。这会成为限制，因为并不是所有需要与发送消息一起做分布式事务的业务操作都支持 XA 协议。</li></ul><h4 id="6-2-1-4-最终一致性解决方案"><a href="#6-2-1-4-最终一致性解决方案" class="headerlink" title="6.2.1.4 最终一致性解决方案"></a>6.2.1.4 最终一致性解决方案</h4><p><img src="https://img-blog.csdnimg.cn/20190615174909234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2NTcwOTQ=,size_16,color_FFFFFF,t_70"></p><p><img src="https://img-blog.csdnimg.cn/2019061517494515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2NTcwOTQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>发送消息的正向流程和检查业务操作结果的反向流程合起来，就是解决业务操作与发送消息一致性的最终一致性方案。</p><p><img src="https://img-blog.csdnimg.cn/20190615175035367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2NTcwOTQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="6-2-2-如何解决消息中间件与使用者的强依赖问题"><a href="#6-2-2-如何解决消息中间件与使用者的强依赖问题" class="headerlink" title="6.2.2 如何解决消息中间件与使用者的强依赖问题"></a>6.2.2 如何解决消息中间件与使用者的强依赖问题</h3><p>消息中间件如果变成了业务应用的必要依赖，那么一旦消息中间件系统（消息存储、业务应用于消息中间件的网络）出现问题，就会导致业务操作无法继续进行。</p><p>要解决这个问题，有如下三种思路：</p><ul><li>提高消息中间件系统的可靠性，但是没有办法保证百分之百可靠。</li><li>对于消息中间件系统中影响业务操作进行的部分，使其可靠性于业务自身的可靠性相同。</li><li>可以提供弱依赖的支持，能够较好的保证一致性。</li></ul><p>如果消息中间件出现问题，我们可以通过消息存储（数据库或磁盘），延迟投递的方案来保证消息一定发送成功。大致有以下几种方式：1、把消息中间件所需要的消息表和业务数据表发到同一个业务数据库中，这样可以把业务操作和写入消息作为一个本地事务来完成。</p><p><img src="https://img-blog.csdnimg.cn/20190615175209295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2NTcwOTQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>这个方案对业务系统有如下三个影响：</p><ul><li>需要业务自己的数据库承载消息数据</li><li>需要让消息中间件去访问业务数据</li><li>需要业务操作的对象是一个数据库，或者说支持事务的存储，并且这个存储必须能够支持消息中间件的需要。</li></ul><p>2、基于第一种改进，消息中间件不再直接和数据库打交道，完全由业务数据库来控制消息的生成、获取、发送及重试的策略。</p><p><img src="https://img-blog.csdnimg.cn/20190615175301615.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2NTcwOTQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>3、上面的方案都依赖于支持事务的数据库操作，具有一定的限制性。我们可以考虑把消息存储到本地磁盘。</p><p><img src="https://img-blog.csdnimg.cn/20190615175320851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2NTcwOTQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>这种方式的风险是，如果消息中间件和本地磁盘的数据都出问题时，消息就会丢失。所以，从业务数据上进行消息补发才是最彻底的容灾手段，因为这样才能保证只要业务数据在，就一定可以有办法恢复消息。</p><p>本地磁盘作为消息存储的方式有两种用法：</p><ol><li>作为一致性发送消息的解决方案的容灾手段。平时不工作，出现问题时才切换到该方式上；</li><li>直接使用该方式工作，这样可以控制业务操作本身调用发送消息的接口处理时间，此外也有机会在业务应用于消息中间件之间做一些批处理的工作。</li></ol><p>业务操作和发送消息一致性的方案所带来的两个限制：</p><ul><li>需要确定要发送的消息的内容。</li><li>需要实现对业务的线程。也就是说为了支持反向流程的工作，业务应用必须能够根据反向流程中发回来的消息内容进行业务操作检查，确认消息所指向的业务操作的状态。</li></ul><h3 id="6-2-3-消息模型对消息接收的影响"><a href="#6-2-3-消息模型对消息接收的影响" class="headerlink" title="6.2.3 消息模型对消息接收的影响"></a>6.2.3 消息模型对消息接收的影响</h3><p>在JMS中，有 Queue（点对点） 和 Topic（发布&#x2F;订阅）两种模型。</p><p>6.2.3.1 JMS Queue 模型</p><p><img src="https://img-blog.csdnimg.cn/20190615175612604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2NTcwOTQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>消息会根据到达的顺序形成一个队列，所有连接到 JMS Queue 上的应用共同消费了所有的消息。如果Queue里面的消息被一个应用处理了，那么其他应用将收不到这个消息。消息从发送端发送出来时不能确定最终会被哪个应用消费，但是可以明确的是只有一个应用会去消费这条消息。JMS Queue 模型也被称为 Peer To Peer （PTP）方式。</p><h4 id="6-2-3-2-JMS-Topic-模型"><a href="#6-2-3-2-JMS-Topic-模型" class="headerlink" title="6.2.3.2 JMS Topic 模型"></a>6.2.3.2 JMS Topic 模型</h4><p><img src="https://img-blog.csdnimg.cn/20190615175707604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2NTcwOTQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>从发送消息的部分和 JMS Topic 内部的逻辑来看，JMS Queue 和 JMS Topic 是一样的，二者最大的区别在于消息接收的部分，在 Topic 模型中，接收消息的应用可以独立收到所有到达 Topic 的消息。JMS Topic 模型也被称为 Pub&#x2F;Sub 方式。</p><p>每个应用可以与JMS 建立多个连接，每个 Connection 都有一个唯一的ClientId，每个连接都是独立获取消息，遵从上述描述。</p><h4 id="6-2-3-4-我们需要什么样的消息模型"><a href="#6-2-3-4-我们需要什么样的消息模型" class="headerlink" title="6.2.3.4 我们需要什么样的消息模型"></a>6.2.3.4 我们需要什么样的消息模型</h4><p><img src="https://img-blog.csdnimg.cn/20190615175756639.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2NTcwOTQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20190615175812115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2NTcwOTQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="6-2-4-消息订阅者订阅消息的方式"><a href="#6-2-4-消息订阅者订阅消息的方式" class="headerlink" title="6.2.4 消息订阅者订阅消息的方式"></a>6.2.4 消息订阅者订阅消息的方式</h3><p><img src="https://img-blog.csdnimg.cn/20190615175839681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2NTcwOTQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20190615175902471.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2NTcwOTQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="6-2-5-保证消息可靠性的做法"><a href="#6-2-5-保证消息可靠性的做法" class="headerlink" title="6.2.5 保证消息可靠性的做法"></a>6.2.5 保证消息可靠性的做法</h3><p><img src="https://img-blog.csdnimg.cn/20190615175953820.png" alt="在这里插入图片描述"></p><p>中间有三个阶段需要保证可靠：消息发送者报消息发送到消息中间件，消息中间件把消息存入消息存储，消息中间件把消息投递给消息接收者。</p><h4 id="6-2-5-1-消息发送端可靠性的保证"><a href="#6-2-5-1-消息发送端可靠性的保证" class="headerlink" title="6.2.5.1 消息发送端可靠性的保证"></a>6.2.5.1 消息发送端可靠性的保证</h4><p>消息发送者需要注意是否真正的发送成功，需要对异常情况进行处理。</p><h4 id="6-2-5-2-消息存储可靠性的保证"><a href="#6-2-5-2-消息存储可靠性的保证" class="headerlink" title="6.2.5.2 消息存储可靠性的保证"></a>6.2.5.2 消息存储可靠性的保证</h4><p><strong>1、实现基于文件的消息存储</strong></p><p>要完全实现基于文件的消息存储需要解决的问题还是比较多的，既要保证读写的吞吐量，又要保证存储的可靠性，应对断电、程序崩溃等问题。因此转向采用现有的数据库引擎的实现。</p><p><strong>2、采用数据库作为消息存储</strong></p><p>采用数据库作为消息存储时，数据库表的设计是相对比较复杂的，通常会采用冗余数据的方式来提高性能。同时需要考虑到的是，消费者集群出现问题，恢复正常后如何正确、快速的处理堆积的消息。</p><p>如果单机出现硬件问题，那么就需要考虑容灾方案：</p><ul><li>单机的Raid</li><li>多机的数据同步。利用存储系统自身的机制完成。数据库的同步复制。</li><li>应用双写。主要是应对存储系统的数据复制有延迟的情况，但同时也让应用变的更复杂。</li></ul><p><strong>3、基于双机内存的消息存储</strong></p><p>由于磁盘IO的原因，上述两种方法系统性能都会受到限制。我们可以使用混合方式进行存储的管理。用双机的内存来保证数据的可靠，正常情况下消息持久存储是不工作的，而基于内存来存储消息则能够提供很高的吞吐量。一旦一个机器出现故障，则停止另一台机器的数据写操作，并把当前数据罗盘。</p><p><img src="https://img-blog.csdnimg.cn/20190615180205926.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2NTcwOTQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="6-2-5-3-消息系统的扩容处理"><a href="#6-2-5-3-消息系统的扩容处理" class="headerlink" title="6.2.5.3 消息系统的扩容处理"></a>6.2.5.3 消息系统的扩容处理</h3><p><strong>1、消息中间件自身如何扩容</strong></p><p><img src="https://img-blog.csdnimg.cn/20190615180311774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2NTcwOTQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>通过server标识消息是来自于哪个消息中间件应用的。</p><p><strong>2、消息存储的扩容处理</strong></p><p>通过服务端主动调度安排投递的方式绕开了根据消息 ID 取消息这个动作，所以可以实现数据库存储的便利扩容。</p><h4 id="6-2-5-4-消息投递的可靠性保证"><a href="#6-2-5-4-消息投递的可靠性保证" class="headerlink" title="6.2.5.4 消息投递的可靠性保证"></a>6.2.5.4 消息投递的可靠性保证</h4><p>消息中间件需要显示地收到接收者确认消息处理完毕的信号才能删除消息。消息接收者不能在收到消息、业务没有处理完成时就去确认消息。同样要注意异常的处理，千万不要吃掉异常然后确认消息处理成功，这样会丢消息。</p><p>消息投递处理的优化：</p><ul><li>多线程的方式处理。投递线程只负责投递消息，等待消息结果返回的工作放到另外的线程池中完成。更新数据库时可以通过 batch 来处理消息的更新、删除操作，从而提升性能。</li><li>如果一个应用中有多个订阅者订阅同样的消息，那么可以通过共享连接，消息只发送一次，传到单机生成多个实例的方式优化。</li></ul><p><img src="https://img-blog.csdnimg.cn/20190615180428455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2NTcwOTQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="6-2-6-订阅者视角的消息重复的产生和应对"><a href="#6-2-6-订阅者视角的消息重复的产生和应对" class="headerlink" title="6.2.6 订阅者视角的消息重复的产生和应对"></a>6.2.6 订阅者视角的消息重复的产生和应对</h3><h4 id="6-2-6-1-消息重复的产生原因"><a href="#6-2-6-1-消息重复的产生原因" class="headerlink" title="6.2.6.1 消息重复的产生原因"></a>6.2.6.1 消息重复的产生原因</h4><p>第一类原因是消息发送端应用的消息重复发送：</p><ul><li>消息中间件在接到消息后存储成功，但这时消息中间件出现问题，导致应用端没有收到消息发送成功的返回，从而进行重试产生了重复。</li><li>消息中间件负载高，消息成功写入消息存储，返回时响应超时。</li><li>由于网络出现问题，导致消息中间件无法响应，发送端重试发送，导致重复。</li></ul><p>原因总结起来就是，在消息成功写入消息存储后，由于各种原因使得发送端没有收到“成功”的返回结果，并且又有重试机制，因而导致重复。</p><p>解决方法是，重试发送消息使用同样的消息ID，而不要在消息中间件端产生消息ID，可以避免这类情况发送。</p><p>第二类原因是消息到达了消息存储，由消息中间件向外投递时产生重复：</p><ul><li>消息被投递到消息接收者应用进行处理，处理完后应用出现问题，消息中间件不知道消息处理结果，会再次投递。</li><li>由于网络问题，消息中间件不知道消息处理结果，会再次投递。</li><li>由于消息应用处理时间较长，消息中间件因为消息超时会再次投递。</li><li>消息中间件出现问题，没能收到消息结果并处理，会再次投递。</li><li>消息存储故障，没能更新投递状态，会再次投递。</li></ul><p>原因总结起来就是，消息接收者成功处理完消息后，消息中间件不能及时更新投递状态造成的。</p><p>解决方法有两种：一种是采用分布式事务来解决，不过这种方式比较复杂，成本也高。另一种是消息接收者的消息处理是幂等操作。</p><p>幂等的含义是采用同样的输入多次调用处理函数，会得到同样的结果。</p><h4 id="6-2-6-2-JMS的消息确认方式与消息重复的关系"><a href="#6-2-6-2-JMS的消息确认方式与消息重复的关系" class="headerlink" title="6.2.6.2 JMS的消息确认方式与消息重复的关系"></a>6.2.6.2 JMS的消息确认方式与消息重复的关系</h4><p>消息接收端对收到的消息确认方式：</p><ul><li>AUTO_ACKNOWLEDGE。自动确认，JMS客户端在收到消息后会自动确认。但是确认时可能消息还没处理或没有处理完成，显然这种方式对于消息投递来说是不可靠的。</li><li>CLIENT_ACKNOWLEDGE。客户端自己确认。客户端需要自己调用 Message 接口的 acknowledge() 方法以进行消息接收成功确认。</li><li>DUPS_OK_ACKNOWLEDGE。在消息接收方的消息处理函数执行结束后进行确认，一方面保证消息一定是处理结束后才进行确认，另一方面也不需要客户端主动调用 Message 接口确认。</li></ul><p>从上面的确认方式，消息接收者对消息的接收会出现两种情况：</p><ol><li>at least once（至少一次）。消息被投递给消息接收者至少一次，也可能多于一次。处理完消息后没有确认的情况下，会造成该现象。</li><li>at most once（至多一次）。消息被投递给消息接收者至多一次。接收到消息时立刻确认的情况下，会造成该现象。</li></ol><p>6.2.7 消息投递的其他属性</p><p><strong>1、消息优先级</strong></p><p><strong>2、订阅者消息处理顺序和分级订阅</strong></p><p><strong>3、自定义属性</strong></p><p><strong>4、局部顺序。</strong> 是指在众多的消息中，和某件事情相关的多条消息之间有顺序，而多个事情之间的消息则没有顺序。</p><p><img src="https://img-blog.csdnimg.cn/20190615180916453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2NTcwOTQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="6-2-8-保证顺序的消息队列的设计"><a href="#6-2-8-保证顺序的消息队列的设计" class="headerlink" title="6.2.8 保证顺序的消息队列的设计"></a>6.2.8 保证顺序的消息队列的设计</h3><p><img src="https://img-blog.csdnimg.cn/20190615180955775.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2NTcwOTQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/2019061518101714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2NTcwOTQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="6-2-8-1-单机多队列的问题和优化"><a href="#6-2-8-1-单机多队列的问题和优化" class="headerlink" title="6.2.8.1 单机多队列的问题和优化"></a>6.2.8.1 单机多队列的问题和优化</h4><p>如果单机的队列数量特别多，性能就会有明显的下降，原因是队列数量很多时，消息写入就接近于随机写了。一个改进措施是把发送到这台机器的消息数据进行顺序写入，然后再根据队列做一个索引，每个队列的索引是独立的，其中保存的只是相对于存储数据的物理队列的索引位置。</p><p><img src="https://img-blog.csdnimg.cn/20190615181049449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2NTcwOTQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="6-2-8-2-解决本地消息存储的可靠性"><a href="#6-2-8-2-解决本地消息存储的可靠性" class="headerlink" title="6.2.8.2 解决本地消息存储的可靠性"></a>6.2.8.2 解决本地消息存储的可靠性</h4><p>采用消息同步复制的方式解决可靠性的问题。</p><ul><li>把单个的消息中间件机器变为主（Master）备（Slave）两个节点，Slave节点订阅Master节点上的所有消息，以进行消息的备份。需要注意的是这是异步操作，Slave订阅收到的消息总会比Master略少一些，存在丢消息的可能。</li><li>第二种是采用同步复制的方式，而非订阅的方式。Master收到消息后会主动写往Slave，并收到Slave的响应后才向消息发送者返回“成功”消息。</li></ul><h4 id="6-2-8-3-如何支持队列的扩容"><a href="#6-2-8-3-如何支持队列的扩容" class="headerlink" title="6.2.8.3 如何支持队列的扩容"></a>6.2.8.3 如何支持队列的扩容</h4><p>基本策略是让消息发送者知道应该把消息写入迁移的新队列中，也需要让消息订阅者知道，当前队列消费完数据后需要迁移到新队列去消费消息。</p><p><img src="https://img-blog.csdnimg.cn/20190615181148331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2NTcwOTQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="6-2-9-Push和Pull方式的对比"><a href="#6-2-9-Push和Pull方式的对比" class="headerlink" title="6.2.9 Push和Pull方式的对比"></a>6.2.9 Push和Pull方式的对比</h3><p><img src="https://img-blog.csdnimg.cn/20190615181205834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2NTcwOTQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/16/Middleware/mybatis/Mybatis%E5%BC%80%E5%90%AFSQL%E8%BE%93%E5%87%BA/"/>
    <url>/2022/05/16/Middleware/mybatis/Mybatis%E5%BC%80%E5%90%AFSQL%E8%BE%93%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="Mybatis笔记"><a href="#Mybatis笔记" class="headerlink" title="Mybatis笔记"></a>Mybatis笔记</h3><h4 id="开启sql输出"><a href="#开启sql输出" class="headerlink" title="开启sql输出"></a>开启sql输出</h4><p>方案1：</p><ul><li><p>将ibatis log4j运行级别调到DEBUG可以在控制台打印出ibatis运行的sql语句</p></li><li><p>添加如下语句</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">###显示SQL语句部分</span><br>log4j.logger.com.ibatis=DEBUG<br>log4j.logger.com.ibatis.common.jdbc.SimpleDataSource=DEBUG<br>log4j.logger.com.ibatis.common.jdbc.ScriptRunner=DEBUG<br>log4j.logger.com.ibatis.sqlmap.engine.impl.SqlMapClientDelegate=DEBUG<br>log4j.logger.Java.sql.Connection=DEBUG<br>log4j.logger.java.sql.Statement=DEBUG<br>log4j.logger.java.sql.PreparedStatement=DEBUG　<br></code></pre></td></tr></table></figure></li></ul><p>方案2：在mybatis.config.xml中增加如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta"><span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD SQL Map Config 3.0//EN&quot;</span></span><br><span class="hljs-meta"><span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br> <br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;STDOUT_LOGGING&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在SpringBoot中，修改application.yml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">mybatis:</span><br><span class="hljs-attr">configuration:</span><br><span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/16/Middleware/DUBBO/"/>
    <url>/2022/05/16/Middleware/DUBBO/</url>
    
    <content type="html"><![CDATA[<h2 id="DUBBO"><a href="#DUBBO" class="headerlink" title="DUBBO"></a>DUBBO</h2><blockquote><p><strong>原因：</strong>通过VPN连接公司内网，会产生一个内网ip，比如10.xx.xx.xx，而本机实际ip有可能是168.xx.xx.xx</p><ol><li>启动服务提供者，注册信息显示服务注册在10.xx.xx.xx</li><li>启动服务消费者，注册信息显示服务注册在168.xx.xx.xx</li></ol><p><strong>现象：</strong>消费者会去10.xx.xx.xx的机器上找对应的服务，导致访问失败</p><p><strong>方案：</strong></p><p><strong>Comsumer设置注册到注册中心的ip——加入环境变量</strong></p><p><a href="https://dubbo.apache.org/zh/docs/v2.7/user/examples/set-host/">https://dubbo.apache.org/zh/docs/v2.7/user/examples/set-host/</a></p><ul><li><p>DUBBO_IP_TO_REGISTRY — 注册到注册中心的ip地址</p></li><li><p>&#x3D;&#x3D;DUBBO_IP_TO_BIND&#x3D;&#x3D; — 监听ip地址<font color=red>起作用的就是这个配置</font></p></li></ul><p>-DDUBBO_IP_TO_BIND&#x3D;10.101.244.99 -DDUBBO_IP_TO_REGISTRY&#x3D;10.101.244.99</p><p><strong>Provider设置注册到注册中心的ip——增加host或者加入环境变量</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">host</span>=<span class="hljs-string">&quot;192.168.0.76&quot;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;$&#123;dubbo.protocol.port:20880&#125;&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dubbo&quot;</span> <span class="hljs-attr">dispatcher</span>=<span class="hljs-string">&quot;$&#123;dubbo.protocol.dispatcher:all&#125;&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">threads</span>=<span class="hljs-string">&quot;$&#123;dubbo.protocol.threads:500&#125;&quot;</span> <span class="hljs-attr">threadpool</span>=<span class="hljs-string">&quot;$&#123;dubbo.protocol.threadPool:limited&#125;&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>-DDUBBO_IP_TO_BIND&#x3D;192.168.0.76 -DDUBBO_IP_TO_REGISTRY&#x3D;192.168.0.76</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">QOS在Dubbo2.7.3以前无法禁用<br>https://github.com/apache/dubbo/issues/4377<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
